#include "stdafx.h"
#include "TRG_FireDanceManager.h"
#include "CreatureSpeedBoost.h"

/// AUTOGENERATED METHODS ///

int TRG_FireDanceManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int TRG_FireDanceManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* TRG_FireDanceManager::GetName() const {
	return "Valla_HorizonBlue::TRG_FireDanceManager";
}

bool TRG_FireDanceManager::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool TRG_FireDanceManager::Read(Simulator::ISerializerStream* stream)
{
	if (mRemoveDancersTask) {
		Simulator::RemoveScheduledTask(mRemoveDancersTask);
	}
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

void TRG_FireDanceManager::Initialize() {
	
}

void TRG_FireDanceManager::Dispose() {
	
}

void TRG_FireDanceManager::Update(int deltaTime, int deltaGameTime) {
	
}

Simulator::Attribute TRG_FireDanceManager::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	Simulator::Attribute()
};

//-----------------------------------------------------------------------------

bool TRG_FireDanceManager::IsDancer(cCreatureCitizenPtr creature) const {
	bool isDancer = false;
	for (auto member : mpDancers) {
		if (member == creature) { return true; }
	}
	return false;
}

// called when a creature plays animation 'soc_fire_dance_turn_fast'
void TRG_FireDanceManager::AddDancer(cCreatureCitizenPtr creature) {
	mpDancers.push_back(creature);
	// after this or 'HitLastDanceAnim' is first called, begin a task to clear the dancer list after a certain amount of time. delete that task when loading new games.
	if (!mRemoveDancersTask) {
		mRemoveDancersTask = Simulator::ScheduleTask(this, &TRG_FireDanceManager::ClearDancers, 6.0f);
	}
}

void TRG_FireDanceManager::ClearDancers() {
	mpDancers.clear();
}

// called when a creature plays animation 'soc_celebrate_trg' and is a dancer
void TRG_FireDanceManager::HitLastDanceAnim(cCreatureCitizenPtr creature) {
	if (IsDancer(creature)) {
		ApplyBonusToDancer(creature);
	}
	// Intentional dulicate:
	// after this or 'AddDancer' is first called, begin a task to clear the dancer list after a certain amount of time. delete that task when loading new games.
	if (!mRemoveDancersTask) {
		mRemoveDancersTask = Simulator::ScheduleTask(this, &TRG_FireDanceManager::ClearDancers, 6.0f);
	}
}


//--------------------------------
// Apply Effects

// play colored fire flare effect
void TRG_FireDanceManager::ShowFireBonusEffect() {
	switch (mCurrentBonus) {
	case Defense:
		break;
	case Damage:
		break;
	case Social:
		break;
	case Speed:
		break;
	}
}

// NOTE: not currently called.
void TRG_FireDanceManager::ApplyBonusToAllDancers() {
	mpBuffedCreatures.clear();
	for (auto member : mpDancers) {
		ApplyBonusToDancer(member);
	}
	mpDancers.clear();
}

// NOTE: Make sure these 2 funcs do not negate the natural bonuses applied to creatures via their traits!
// It may be good, when resetting the bonuses, to send a message that MemberManager can listen for
// that tells it to reset the creature's bonuses based off their traits.
void TRG_FireDanceManager::ApplyBonusToDancer(cCreatureCitizenPtr creature) {
	SporeDebugPrint("Applying dance bonus.");
	switch (mCurrentBonus) {
		case Defense:
			creature->mHasArmorBoost = true;
			creature->mArmorBoostAmount = 2.0f;
			break;
		case Damage:
			creature->mHasDamageBoost = true;
			creature->mDamageBoostAmount = 1.5f;
			break;
		case Social:
			//creature-> = true;
			//creature-> = 1.5f;
			break;
		case Speed:
			mCreatureSpeedBoost->ApplySpeedBoost(creature, 40); // TODO: have this depend on its base speed capability?
			// DEBUG
			creature->SetIdentityColor(ColorRGB(10, 0, 0));
			break;
	}
	// add to the buffed list
	mpBuffedCreatures.push_back(creature);
}

void TRG_FireDanceManager::ResetBonusForCreature(cCreatureCitizenPtr creature, TRG_FireDanceManager::Bonus bonus) {
	switch (bonus) {
	case Defense:
		break;
	case Damage:
		break;
	case Social:
		break;
	case Speed:
		break;
	}
}