#include "stdafx.h"
#include "CRG_Inventory.h"
#include "CRG_ObjectManager.h"

/// AUTOGENERATED METHODS ///

int CRG_Inventory::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int CRG_Inventory::Release() {
	return Simulator::cStrategy::Release();
}

const char* CRG_Inventory::GetName() const {
	return "Valla_CreatureOverhaul::CRG_Inventory";
}

bool CRG_Inventory::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool CRG_Inventory::Read(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}
// You can extend this function to return any other types your class implements.
void* CRG_Inventory::Cast(uint32_t type) const
{
	//CLASS_CAST(Simulator::cStrategy);
	CLASS_CAST(Object);
	CLASS_CAST(IWinProc);
	CLASS_CAST(CRG_Inventory);
	return nullptr;
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

Simulator::Attribute CRG_Inventory::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	Simulator::Attribute()
};

void CRG_Inventory::Initialize() {
	WindowManager.GetMainWindow()->AddWinProc(this);
	MessageManager.AddListener(this, kMsgRestartAtNest);
	MessageManager.AddListener(this, kMsgCombatantKilled);
	MessageManager.AddListener(this, id("BabyGrowUp"));

	SimulatorSystem.AddStrategy(this, NOUN_ID);
}

void CRG_Inventory::Dispose() {
	
}

void CRG_Inventory::Update(int deltaTime, int deltaGameTime) {
	
}

//----------------------------------------------------------------------------

bool CRG_Inventory::ShouldStoreFood() const {
	if (!IsCreatureGame()) { return false; }
	auto avatar = GameNounManager.GetAvatar();
	if (!avatar) { return false; }

	auto slotidx = GetOpenSlotIndex();
	if (slotidx < 0)
	{
		return false;
	}


	if ((100.0f - avatar->mHunger < 6.0f) && (avatar->mMaxHealthPoints - avatar->mHealthPoints < 0.8f)) {
		// creature is full, store the food
		return true;
	}
	// creature is not full or is missing health, eat the food
	return false;
}

uint32_t CRG_Inventory::GetFoodStoreAnim(uint32_t animID) {
	auto avatar = GameNounManager.GetAvatar();
	if (!avatar) { return animID; }

	int herb = CapabilityChecker::GetCapabilityLevel(avatar, 0x022E785C);
	int carn = CapabilityChecker::GetCapabilityLevel(avatar, 0x022E7847);

	if (herb) {
		for (size_t i = 0; i < eatFruitAnims.size(); i++) {
			if (eatFruitAnims[i] == animID) {
				SporeDebugPrint("Store Fruit");
				StoreFood(Fruit);
				return StoreFruit;
			}
		}
	}
	
	if (carn) {
		for (size_t j = 0; j < eatMeatAnims.size(); j++) {
			if (eatMeatAnims[j] == animID) {
				SporeDebugPrint("Store Meat");
				StoreFood(Meat);
				return StoreMeat;
			}
		}
	}
	return animID;
}

// Called via a signal in the animation
void CRG_Inventory::StoreFood(uint32_t foodType) {
	AddItemToInventory(foodType);
}

//----------------------------------------------------------------------------

bool CRG_Inventory::AddItemToInventory(uint32_t itemID) {
	int idx = GetOpenSlotIndex();
	// valid item
	if (idx > -1 && idx < int(mInventory.capacity())) {
		SetSlotItem(itemID, idx);
		return true;
	}
	// invalid item, return false
	else {
		return false;
	}
}

void CRG_Inventory::ConsumeItemAtSlot(int index) {
	auto avatar = GameNounManager.GetAvatar();
	if (!avatar) { return; }
	auto itemResource = GetSlotItemResource(index);
	auto anim = ObjectManager.GetModelInteractAnim(itemResource, 0x0, true);
	avatar->PlayAnimation(anim);
	// TODO: delay these lines until the animation hits the point where they actually eat it.
	// maybe store an integer of what item is being used, so that it cannot be re-used again while eating it.
	// Or maybe consider removing the item instantly and only relaying the reward, and if you get attacked
	ObjectManager.ApplyModelRewards(avatar, itemResource, true);
	RemoveItemAtSlot(index);
}

void CRG_Inventory::RemoveItemAtSlot(int index) {
	SetSlotItem(0x0, index);
}


ResourceKey CRG_Inventory::GetItemResource(uint32_t itemID) const {
	return ResourceKey(itemID, Names::prop, itemPath);
}

ResourceKey CRG_Inventory::GetItemImage(ResourceKey itemKey) const {
	return CapabilityChecker::GetModelKeyValue(itemKey, id("itemImageID"));
}

// get first open slot, or -1 if no open slots
int CRG_Inventory::GetOpenSlotIndex() const {
	for (size_t i = 0; i < mInventory.size(); i++) {
		if (mInventory[i] == 0x0) { // make sure this line is working in debug
			if (i < 7) {
				return i;
			}
			else {
				return -1;
			}
		}
	}
	return mInventory.size();
}

// get the window that shows and hides the UI
IWindow* CRG_Inventory::GetPopupWindow() const {
	auto window = WindowManager.GetMainWindow();
	auto popup = window->FindWindowByID(0xD56BAD2A);
	return popup;
}

// get the button that holds the icon, caption, etc
IWindow* CRG_Inventory::GetSlotWindow(int index) const {
	auto window = WindowManager.GetMainWindow();
	auto slot = window->FindWindowByID(Slot0+index);
	return slot;
}

ResourceKey CRG_Inventory::GetSlotItemResource(int index) const {
	return GetItemResource(mInventory[index]);
}

// add item to slot, 0x0 to clear
void CRG_Inventory::SetSlotItem(uint32_t itemID, int index) {
	if (index >= int(mInventory.size()) && index < int(mInventory.capacity())) {
		mInventory.push_back(itemID);
	}
	else {
		mInventory[index] = itemID;
	}
	auto window = GetSlotWindow(index);
	auto imagewindow = window->FindWindowByID(0x000000A1);
	// valid, add item
	if (itemID != 0x0) {
		auto key = GetItemResource(itemID);
		auto imageKey = GetItemImage(key);
		object_cast<IImageDrawable>(imagewindow->GetDrawable())->SetImageForWindow(imagewindow, imageKey);
		window->SetEnabled(true);
		imagewindow->SetVisible(true);
	}
	// invalid, remove item
	else {
		window->SetEnabled(false);
		imagewindow->SetVisible(false);
	}

}

float temp_creaturescale = 0.0f;
void CRG_Inventory::DelayCreatureAgeCheck() {
	auto avatar = GameNounManager.GetAvatar();
	temp_creaturescale = avatar->GetScale();
	Simulator::ScheduleTask(this, &CRG_Inventory::CheckCreatureAge, 0.3f);
}

void CRG_Inventory::CheckCreatureAge() {
	auto avatar = GameNounManager.GetAvatar();
	bool is_growing = (temp_creaturescale > 0 && avatar->GetScale() > temp_creaturescale);

	if (avatar && avatar->mAge > 0 || is_growing) {
		EnableInventory();
	}
	else {
		DisableInventory();
	}
	temp_creaturescale = 0.0f;
}

//----------------------------------------------------------------------------

void CRG_Inventory::ClickInventoryItem(int index) {
	ConsumeItemAtSlot(index);
}

void CRG_Inventory::EnableInventory() {
	auto window = GetPopupWindow();
	window->SetEnabled(true);
}


void CRG_Inventory::DisableInventory() {
	auto window = GetPopupWindow();
	window->SetEnabled(false);
}

void CRG_Inventory::ClearInventory() {
	SetSlotItem(0x0,0);
	SetSlotItem(0x0,1);
	SetSlotItem(0x0,2);
	SetSlotItem(0x0,3);
	SetSlotItem(0x0,4);
	SetSlotItem(0x0,5);
	SetSlotItem(0x0,6);
}

//----------------------------------------------------------------------------

int CRG_Inventory::GetEventFlags() const
{
	return kEventFlagBasicInput | kEventFlagAdvanced;
}


// Ingame mouse messages
bool CRG_Inventory::HandleUIMessage(IWindow* window, const Message& message)
{
	if (!IsCreatureGame()) { return false; }

	//------------------------------------------------------
	// Inventory UI Buttons

	if (message.IsType(kMsgButtonClick)) {
		auto id = message.source->GetControlID();
		if (id >= Slot0 && id <= Slot6) {
			ClickInventoryItem(id - Slot0);
		}
	}

	// Return true if the message was handled, and therefore no other window procedure should receive it.
	return false;
}

bool CRG_Inventory::HandleMessage(uint32_t messageID, void* msg)
{
	if (!IsCreatureGame()) { return false; }

	if (messageID == id("BabyGrowUp"))
	{
		DelayCreatureAgeCheck();
	}
	else if (messageID == kMsgRestartAtNest)
	{
		DisableInventory();
	}
	else if (messageID == kMsgCombatantKilled) {
		auto killMsg = (CombatantKilledMessage*)msg; // cast to this message type
		if (killMsg) {
			auto avatar = GameNounManager.GetAvatar();

			// if player is killed, clear the inventory
			if (killMsg->GetCombatant() == avatar) {
				ClearInventory();
				DisableInventory();
			}
		}
	}
		
	return false;
}