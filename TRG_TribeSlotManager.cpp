#include "stdafx.h"
#include "TRG_TribeSlotManager.h"

/// AUTOGENERATED METHODS ///

int TRG_TribeSlotManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int TRG_TribeSlotManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* TRG_TribeSlotManager::GetName() const {
	return "Valla_HorizonBlue::TRG_TribeSlotManager";
}

bool TRG_TribeSlotManager::Write(Simulator::ISerializerStream* stream)
{
	mStoredSlotPositions.clear();
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool TRG_TribeSlotManager::Read(Simulator::ISerializerStream* stream)
{
	mStoredSlotPositions.clear();
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

Simulator::Attribute TRG_TribeSlotManager::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	Simulator::Attribute()
};

void TRG_TribeSlotManager::Initialize() {
	
}

void TRG_TribeSlotManager::Dispose() {
	
}

void TRG_TribeSlotManager::Update(int deltaTime, int deltaGameTime) {
	
}

//--------------------------------------------------------------------

cCommunityLayout& TRG_TribeSlotManager::GetTribeLayout() const {
	auto tribe = GameNounManager.GetPlayerTribe();
	if (tribe) {
		return tribe->mTribeLayout;
	}
	static auto layout = cCommunityLayout();
	// return empty if invalid to avoid crash
	return layout;
}

void TRG_TribeSlotManager::StoreSlots() {
	// only store them if not already stored.
	if (mStoredSlotPositions.size() == 0) {

		for (size_t i = 0; i < GetTribeLayout().mSlots.size(); i++) {
			mStoredSlotPositions.push_back(GetTribeLayout().mSlots[i].mPosition);
		}
	}
	// if already stored, add any new data.
	else {
		if (mStoredSlotPositions.size() < GetTribeLayout().mSlots.size()) {
			// start from end of stored data and go to the end of the current slots
			for (size_t i = mStoredSlotPositions.size(); i < GetTribeLayout().mSlots.size(); i++) {
				mStoredSlotPositions.push_back(GetTribeLayout().mSlots[i].mPosition);
			}
		}
	}
}

void TRG_TribeSlotManager::RestoreSlots() {
	for (size_t i = 0; i < mStoredSlotPositions.size(); i++) {
		GetTribeLayout().mSlots[i].mPosition = mStoredSlotPositions[i];
	}
	mStoredSlotPositions.clear();
}

void TRG_TribeSlotManager::AddSlot(SlotType slotType, Vector3 pos) {
	cLayoutSlot newSlot;
	newSlot.field_8 = slotType;
	newSlot.mIsOccupied = false;
	newSlot.mPosition = pos;

	GetTribeLayout().mSlots.push_back(newSlot);
}

void TRG_TribeSlotManager::ActivateSlotType(SlotType slotType) {
	// restore all slots, and if the active slot type is specific, store them again in prep to remove some.
	RestoreSlots();
	if (slotType != Any) {
		StoreSlots();
		// now, find all slots that dont match the current slot type (except slot type "any"), and hide those.
		for (size_t i = 0; i < GetTribeLayout().mSlots.size(); i++) {
			if (GetTribeLayout().mSlots[i].field_8 != slotType && GetTribeLayout().mSlots[i].field_8 != Any) {
				GetTribeLayout().mSlots[i].mPosition = Vector3(0, 0, 0);
			}
		}
	}
}

// TODO: see the maych thing in shh! moving the positions of the vectors will NOT work because it will allow existing objects to be displaced or the new objects to be moved to an invalid slot.
// we NEED to use the clearing and restoring the slots method.