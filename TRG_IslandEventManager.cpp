#include "stdafx.h"
#include "TRG_IslandEventManager.h"

/// AUTOGENERATED METHODS ///

TRG_IslandEventManager::TRG_IslandEventManager()
{
	SporeDebugPrint("Island Event Manager is initialized.");
	SimulatorSystem.AddStrategy(this, NOUN_ID);

	CursorManager.Load(0x24C6D844, u"cursor_unknown");
	WindowManager.GetMainWindow()->AddWinProc(this);

	eventUIlayout.LoadByID(0xA59316FC);
}

TRG_IslandEventManager::~TRG_IslandEventManager()
{
}

int TRG_IslandEventManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int TRG_IslandEventManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* TRG_IslandEventManager::GetName() const {
	return "Valla_CreatureOverhaul::TRG_IslandEventManager";
}

bool TRG_IslandEventManager::Write(Simulator::ISerializerStream* stream)
{
	SporeDebugPrint("Island Event Manager is writing...");
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool TRG_IslandEventManager::Read(Simulator::ISerializerStream* stream)
{
	SporeDebugPrint("Island Event Manager is reading...");
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

//-----------------------------------------------------------------------------------

void TRG_IslandEventManager::Initialize() {
	
}

void TRG_IslandEventManager::Dispose() {
	if (mTask) {
		Simulator::RemoveScheduledTask(mTask);
		mTask = nullptr;
	}
}

void TRG_IslandEventManager::Update(int deltaTime, int deltaGameTime) {
	if (mbItemWasClicked && mpEventItem && mpActivators.size() > 0) {
		auto activator = GetActivatorWithinItemRange();
		if (activator) {
			ShowEventUI();
		}
	}
	if (GameViewManager.GetHoveredObject() == mpEventItem.get()) {
		UI::SimulatorRollover::ShowRollover(mpEventItem.get());
	}
}

//-----------------------------------------------------------------------------------

void TRG_IslandEventManager::OnModeEntered(uint32_t previousModeID, uint32_t newModeID) {
	cStrategy::OnModeEntered(previousModeID, newModeID);
	// Entered
	if (newModeID != previousModeID && newModeID == kGameTribe) {
		SporeDebugPrint("Island Event Manager is ready to use in Tribal Stage.");
		StartItemTimer();
		SpawnDummyTribe();
		// Tribe names reset upon load, make sure the dummy tribe restores its name so the event item looks correct.
		if (mpEventItem) {
			Simulator::ScheduleTask(this, &TRG_IslandEventManager::RestoreName, 0.01f); return;
		}
	}
	// Exited
	else {
		if (mTask) {
			Simulator::RemoveScheduledTask(mTask);
			mTask = nullptr;
		}
	}
}

void TRG_IslandEventManager::RestoreName() {
	if (mpEventItem && mpDummyTribe) {
		mpDummyTribe->SetName(GetEventItemNameChar(mpEventItem->GetModelKey()));
	}
}

// Generate a tribe on the "dark side" of the planet to use as a fake tribe ID for objects.
void TRG_IslandEventManager::SpawnDummyTribe() {
	// if already exists, return
	if (!IsTribeGame() || mpDummyTribe) { return; }

	// ensure the player tribe exists. if not, wait and run this again.
	auto playerTribe = GameNounManager.GetPlayerTribe();
	if (!playerTribe) { Simulator::ScheduleTask(this, &TRG_IslandEventManager::SpawnDummyTribe, 4.0f); return; }


	mSavedHut = playerTribe->mpHut.get();
	// find the side of the planet opposite of the player, so it is out of sight
	Vector3 pos;
	float tribeDist = Math::distance(Vector3(0, 0, 0), playerTribe->GetPosition());
	// find inverse dir
	Vector3 tribeDir = (Vector3(0, 0, 0) - playerTribe->GetPosition()).Normalized();

	// Spawn tribe
	auto species = playerTribe->mTribeMembers[0]->mpSpeciesProfile;
	mpDummyTribe = Simulator::SpawnNpcTribe(tribeDir * tribeDist, 0, 0, 0, true, species);

	// Make tribe appear destroyed, just to psych out the lore-nerds >:)
	mpDummyTribe->mpHut->mHealthPoints = mpDummyTribe->mpHut->mMaxHealthPoints / 3.0f;
	//auto model = ResourceKey(id("HE_destroyed_hut"), Names::prop, id("hutstyles"));
	//auto model = ResourceKey(id("tt_hut_home_dest"), Names::prop, id("TribalTools"));
	auto model = ResourceKey();
	mpDummyTribe->mpHut->SetModelKey(model);
	mpDummyTribe->mpHut->mDestructModelHi = model;
	mpDummyTribe->mpHut->mDestructModelMd = model;
	mpDummyTribe->mpHut->mDestructModelLo = model;
	mpDummyTribe->mpHut->mUndamagedModel = model;
	// find fire pit, make it appear burned out
	for (auto tool : mpDummyTribe->mTools) {
		if (tool->GetModelKey().instanceID == id("tt_firepit_home_01")) {
			tool->SetModelKey(ResourceKey(id("tt_firepit_home_dest"), Names::prop, id("TribalTools")));
			return;
		}
	}
	
}

// Spawn a chest
void TRG_IslandEventManager::SpawnEventItem() {
	SporeDebugPrint("Spawning Event Item...");

	mbItemHovered = false;
	mpActivators.clear();
	mbItemWasClicked = false;

	auto spawnPoint = FindSpawnPoint();
	if (spawnPoint && mpDummyTribe) {
		// pull data from random model file
		auto modelKey = GetEventItemModelKey();
		auto name = GetEventItemNameChar(modelKey);

		mpEventItem = simulator_new<Simulator::cTribeHut>();
		mpEventItem->mpTribe = mpDummyTribe;
		mpDummyTribe->SetName(name);
		//mEventItemName = name;

		mpEventItem->mUndamagedModel = modelKey;
		mpEventItem->SetModelKey(modelKey);
		mpEventItem->Teleport(spawnPoint->GetPosition(), spawnPoint->GetOrientation());
		mpEventItem->mbTransformDirty = false;
		mpEventItem->SetScale(eventItemScale);


		mpEventItem->mbFixed = true;
		mpEventItem->mbPickable = true;
		mpEventItem->mbIsTangible = true;
		mpEventItem->mbIsGhost = false;
	}
	if (!mpEventItem || mpEventItem->GetModelKey() == ResourceKey()) {
		SporeDebugPrint("Spawning Failed.");
	}	

	StartItemTimer();

}

// Remove the chest
void TRG_IslandEventManager::RemoveEventItem() {
	SporeDebugPrint("Removing Event Item");
	mbItemHovered = false;
	mpActivators.clear();
	mbItemWasClicked = false;
	mpEventItem->SetIsSelected(false);
	GameNounManager.DestroyInstance(mpEventItem.get());
	mpEventItem = nullptr;
	StartItemTimer();
}

// if the item is onscreen, it cannot be removed!
// call this func again in a second to check if that is still the case.
void TRG_IslandEventManager::TryRemoveEventItem() {
	if (!mpEventItem->mbInView) {
		//mpEventItem->mDistanceFromCamera
		RemoveEventItem();
	}
	else {
		SporeDebugPrint("Unable to remove Event Item.");
		mTask = Simulator::ScheduleTask(this, &TRG_IslandEventManager::TryRemoveEventItem, 1.0f);
	}
}

// Select the chest and store currently selected creatures
void TRG_IslandEventManager::SelectEventItem() {
	mpEventItem->SetIsSelected(true);
	mpEventItem->SetIsRolledOver(true);
	//mpActivators.clear();
	//mpActivators = GetSelectedCitizens();
}

//---------------------------------

ResourceKey TRG_IslandEventManager::GetEventItemModelKey() {
	// if the item exists, get its current key
	if (mpEventItem) {
		return mpEventItem->GetModelKey();
	}
	// if it does not exist, find a new one from the manifest.
	else {
		// load the event item manifest
		PropertyListPtr mpPropList;
		size_t keycount;
		uint32_t* keys;
		if (PropManager.GetPropertyList(mEventManifestKey.instanceID, mEventManifestKey.groupID, mpPropList))
		{
			if (App::Property::GetArrayUInt32(mpPropList.get(), id("eventModels"), keycount, keys)) {
				if (keycount > 0) {
					int idx = -1;
					int tries = 20;
					while (idx == last_object_idx && tries > 0) {
						tries -= 1;
						idx = rand(keycount);
					}
					last_object_idx = idx;
					return ResourceKey(keys[idx], Names::prop, Models);
				}
			}
		}
	}
	return ResourceKey();
}

ResourceKey TRG_IslandEventManager::GetEventPrompt(ResourceKey res) const {
	// load the event item manifest
	PropertyListPtr mpPropList;
	size_t keycount;
	ResourceKey* keys;
	if (PropManager.GetPropertyList(res.instanceID, res.groupID, mpPropList))
	{
		if (App::Property::GetArrayKey(mpPropList.get(), id("resultEvents"), keycount, keys)) {
			if (keycount > 0) {
				int idx = rand(keycount);
				return keys[idx];
			}
		}
	}
	return ResourceKey();
}

LocalizedString TRG_IslandEventManager::GetEventItemName(ResourceKey model) const {
	PropertyListPtr mpPropList;
	LocalizedString localetext;
	if (PropManager.GetPropertyList(model.instanceID, model.groupID, mpPropList))
	{
		if (App::Property::GetText(mpPropList.get(), 0x8F6FC401, localetext)) { // blockname
			return localetext;
		}
	}
	// blank
	return LocalizedString(0x0, 0x0, u"Mysterious Item");
}


const char16_t* TRG_IslandEventManager::GetEventItemNameChar(ResourceKey model) const {
	PropertyListPtr mpPropList;
	LocalizedString localetext;
	if (PropManager.GetPropertyList(model.instanceID, model.groupID, mpPropList))
	{
		if (App::Property::GetText(mpPropList.get(), 0x8F6FC401, localetext)) { // blockname
			return localetext.GetText();
		}
	}
	return LocalizedString().GetText();
}


//-----------------------------------------------------------------------------------

// TODO: fix offscreen object deletion to work, bump up timers
void TRG_IslandEventManager::StartItemTimer() {
	float time;
	// no item, start timer to spawn one in
	if (!mpEventItem) {
		time = GetFloatFromVecRange(timeBetweenSpawns);
		mTask = Simulator::ScheduleTask(this, &TRG_IslandEventManager::SpawnEventItem, time);
	}
	// item exists, start timer to delete it.
	else {
		time = GetFloatFromVecRange(timeItemLifetime);
		mTask = Simulator::ScheduleTask(this, &TRG_IslandEventManager::TryRemoveEventItem, time);
	}
}

cSpatialObjectPtr TRG_IslandEventManager::FindSpawnPoint() {
	vector<cSpatialObjectPtr> spawnpoints = {};
	auto spatials = GetDataByCast<cSpatialObject>();
	for (auto item : spatials) {
		auto modelID = item->GetModelKey().instanceID;
		if (modelID == id("TRG_lootmarker_beach")) {
			spawnpoints.push_back(item);
		}
	}

	// backup: if no items were found, spawn it over one of the small coast rocks instead.
	if (spawnpoints.size() == 0) {
		for (auto item : spatials) {
			auto modelID = item->GetModelKey().instanceID;
			if (modelID == id("cr_planet_rock_small01b") || modelID == id("cr_planet_rock_small02b")) {
				spawnpoints.push_back(item);
			}
		}
	}

	if (spawnpoints.size() > 0) {
		// find 3 random points to choose from
		//-----------------------------------------------
		fixed_vector<int, 3> indices;
		int tries = 20;

		indices.push_back(rand(spawnpoints.size()));
		indices.push_back(rand(spawnpoints.size()));
		// if the same, re-randomize
		while (indices[1] == indices[0] && tries > 0) {
			indices[1] = rand(spawnpoints.size());
			tries -= 1;
		}
		indices.push_back(rand(spawnpoints.size()));
		tries = 20;
		// if the same, re-randomize
		while (indices[2] == indices[1] || indices[2] == indices[0] && tries > 0) {
			indices[2] = rand(spawnpoints.size());
			tries -= 1;
		}
		//-----------------------------------------------
		// then pick the closest to any player villager
		float distanceClosest = 4096;
		int index = -1;
		for (auto pointidx : indices) {
			// find closest creature distance
			for (auto creature : GameNounManager.GetPlayerTribe()->GetTribeMembers()) {
				float dist = Math::distance(creature->GetPosition(), spawnpoints[pointidx]->GetPosition());
				if (dist < distanceClosest) {
					distanceClosest = dist;
					index = pointidx;
				}
			}
		}

		if (index == -1) { return nullptr; }

		auto item = spawnpoints[index];

		// hide item it will spawn on top of
		item->SetScale(0.1f);
		return item;
	}

	
	else {
		for (auto item : spatials) {
			auto modelID = item->GetModelKey().instanceID;
			if (modelID == id("cr_planet_rock_small01b") || modelID == id("cr_planet_rock_small02b")) {
				spawnpoints.push_back(item);
			}
		}
		if (spawnpoints.size() > 0) {
			return spawnpoints[rand(spawnpoints.size())];
		}
	}

	return nullptr;
}

float TRG_IslandEventManager::GetFloatFromVecRange(Vector2 range) const {
	float diff = range.y - range.x;
	return (randf() * diff) + range.x;
}

vector<cCreatureCitizenPtr> TRG_IslandEventManager::GetSelectedCitizens() const {
	vector<cCreatureCitizenPtr> selectedCreatures = {};
	auto tribe = GameNounManager.GetPlayerTribe();
	if (!tribe) { return selectedCreatures; }
	for (auto creature : tribe->GetTribeMembers()) {
		if (creature->IsSelected()) {
			selectedCreatures.push_back(creature);
		}
		
	}
	return selectedCreatures;
}

bool TRG_IslandEventManager::IsEventItemHovered() const {
	if (mpEventItem) {
		return mpEventItem->IsRolledOver();
	}
	return false;
}

/*
bool TRG_IslandEventManager::TraceCanHandleModel(Graphics::Model* model) {
	if (object_cast<cGamePlant>(model->mpOwner)) { return false; }
	return true;
}

bool TRG_IslandEventManager::TraceHitEventObject() const {

	auto pViewer = CameraManager.GetViewer();

	Vector3 camPos = Vector3(0, 0, 0);
	Vector3 camDir = Vector3(0, 0, 0);

	// Get vector to the center of the screen.
	auto windowArea = WindowManager.GetMainWindow()->GetArea();
	pViewer->GetCameraToMouse(camPos, camDir);

	vector<cSpatialObjectPtr> raycastObjects;

	if (GameViewManager.RaycastAll(camPos, camPos + (camDir * 900.0f), raycastObjects, true)) {
		for (auto object : raycastObjects) {
			// if hit a tribal building before an object, return false.
			//if (object_cast<cTribeTool>(object) || object_cast<cTribeHut>(object)) {
			//	return false;
			//}
			//auto worldObject = object_cast<cInteractiveOrnament>(object);
			auto worldObject = object_cast<cTribeHut>(object);
			if (worldObject && worldObject == mpEventItem) {
				return true;
			}
		}

	}
	return false;
}*/

//-----------------------------------------------------------------------------------

bool TRG_IslandEventManager::ClickedEventItem(int mouseButton, bool clicked) {
	if (mouseButton == 0) {
		auto window = WindowManager.GetMainWindow();
		auto playerTribe = GameNounManager.GetPlayerTribe();

		if (clicked) {
			if (mUITask && !mUITask->HasExecuted()) {
				//Simulator::RemoveScheduledTask(mUITask);
				return true;
			}
			mpEventItem->mpTribe = playerTribe;

			auto itemnamefield = window->FindWindowByID(kItemNameField);
			if (itemnamefield) {
				itemnamefield->SetCaption(mpDummyTribe->GetName());
			}
		}
		else {
			// do this to prevent the window from jumping around
			if (IsEventItemHovered()) {
				playerTribe->mpHut = mpEventItem;
			}
			if (mUITask && !mUITask->HasExecuted()) {
				Simulator::RemoveScheduledTask(mUITask);
			}
			mUITask = Simulator::ScheduleTask(this, &TRG_IslandEventManager::UnLeftClickedEventItem, 0.0001f);
			return false;
		}
	}
	return false;
}

cCreatureCitizenPtr TRG_IslandEventManager::GetActivatorWithinItemRange() const {
	for (auto member : mpActivators) {
		if (member && Math::distance(member->GetPosition(), mpEventItem->GetPosition()) <= eventItemActivationRadius) {
			return member;
		}
	}
	return nullptr;
}

// This is its own func since it needs to be delayed.
void TRG_IslandEventManager::UnLeftClickedEventItem() {
	if (mpEventItem) {
		auto playertribe = GameNounManager.GetPlayerTribe();
		if (IsEventItemHovered()) {
			if (mSavedHut) {
				playertribe->mpHut = mSavedHut;
			}
		}
		
		mpEventItem->mpTribe = mpDummyTribe;
	}
}

bool TRG_IslandEventManager::IsCreatureActivator(cCreatureCitizenPtr member) const {
	if (mpActivators.size() == 0) { return false; }
	bool has_member = false;
	for (auto item : mpActivators) {
		if (item == member) {
			has_member = true;
		}
	}
	return has_member;
}

void TRG_IslandEventManager::AddCreatureToActivators(cCreatureCitizenPtr member) {
	if (!IsCreatureActivator(member)) {
		// find open spot
		int index = -1;
		for (size_t i = 0; i < mpActivators.size(); i++) {
			if (mpActivators[i] == nullptr) {
				index = i;
			}
		}
		if (index > -1) {
			mpActivators[index] = member;
		}
		else {
			mpActivators.push_back(member);
		}
	}
}

void TRG_IslandEventManager::RemoveCreatureFromActivators(cCreatureCitizenPtr member) {
	int index = -1;
	for (size_t i = 0; i < mpActivators.size(); i++) {
		if (mpActivators[i] == member) {
			index = i;
		}
	}
	if (index > -1) {
		mpActivators[index] = nullptr;
	}
}


void TRG_IslandEventManager::GoToEventItem() {
	mbItemWasClicked = true;

	for (auto member : GameNounManager.GetPlayerTribe()->GetTribeMembers()) {
		if (member->IsSelected()) {
			AddCreatureToActivators(member);
			member->DoAction(kCitizenActionRepair, mpEventItem.get());
		}
	}
}



//-----------------------------------------------------------------------------------
// Custom UI Funcs

// TODO: use the part model to find a list of prompts to show.
// Then use the randomly chosen prompt to fill out data in the UI
void TRG_IslandEventManager::ShowEventUI() {
	if (!IsTribeGame()) { return; }
	MessageManager.MessageSend(id("DropCreature"),nullptr);
	mbItemWasClicked = false;
	GameTimeManager.Pause(TimeManagerPause::Cinematic);

	eventUIlayout.FindWindowByID(WinMain)->SetVisible(true);
	eventUIlayout.FindWindowByID(WinShadow)->SetVisible(true);

	FillEventUIData(GetEventPrompt(mpEventItem->GetModelKey()));
}

void TRG_IslandEventManager::HideEventUI() {
	mbItemWasClicked = false;
	for (auto member : mpActivators) {
		member->DoAction(kCitizenActionGather, nullptr);
	}
	mpActivators.clear();
	eventUIlayout.FindWindowByID(WinMain)->SetVisible(false);
	eventUIlayout.FindWindowByID(WinShadow)->SetVisible(false);
	GameTimeManager.Resume(TimeManagerPause::Cinematic);
}

void TRG_IslandEventManager::EventUIClickButton(bool confirmed) {
	HideEventUI();
}

// load the UI data from the event item's prop file, and assign it to the window
void TRG_IslandEventManager::FillEventUIData(ResourceKey eventPromptKey) {
	//ResourceKey mEventPromptKey = GetEventPrompt(mpEventItem->GetModelKey());

	// load the properties of the model
	PropertyListPtr mpPropList;
	ResourceKey key;
	if (PropManager.GetPropertyList(eventPromptKey.instanceID, eventPromptKey.groupID, mpPropList))
	{
		LocalizedString eventText = LocalizedString();
		LocalizedString eventTextCancelled = LocalizedString();
		LocalizedString textConfirm = LocalizedString();
		LocalizedString textCancel = LocalizedString();
		ResourceKey eventImageID = ResourceKey();

		App::Property::GetText(mpPropList.get(), id("eventText"), eventText);
		App::Property::GetText(mpPropList.get(), id("eventTextCancelled"), eventTextCancelled);
		App::Property::GetText(mpPropList.get(), id("textConfirm"), textConfirm);
		App::Property::GetText(mpPropList.get(), id("textCancel"), textCancel);
		App::Property::GetKey(mpPropList.get(), id("eventImageID"), eventImageID);

		auto imagefield = eventUIlayout.FindWindowByID(WinImage);
		auto textfield = eventUIlayout.FindWindowByID(WinText);
		auto confirm = eventUIlayout.FindWindowByID(WinConfirm);
		auto cancel = eventUIlayout.FindWindowByID(WinCancel);
		auto close = eventUIlayout.FindWindowByID(WinClose);

		textfield->SetCaption(eventText.GetText()); // TODO: swap text variables. make a static func for this.
		object_cast<UTFWin::IImageDrawable>(imagefield->GetDrawable())->SetImageForWindow(imagefield, eventImageID);
		//image->(eventText.GetText()); // TODO: swap names

		// show prompt buttons
		if (!string16(textConfirm.GetText()).empty()) {

			close->SetVisible(false);

			confirm->SetVisible(true);
			confirm->SetCaption(textConfirm.GetText());

			cancel->SetVisible(true);
			cancel->SetCaption(textCancel.GetText());
		}
		// show close button
		else {
			close->SetVisible(true);
			confirm->SetVisible(false);
			cancel->SetVisible(false);
		}

		
	}
}

//-----------------------------------------------------------------------------------

int TRG_IslandEventManager::GetEventFlags() const
{
	return kEventFlagBasicInput | kEventFlagAdvanced;
}


// Ingame mouse messages
bool TRG_IslandEventManager::HandleUIMessage(IWindow* window, const Message& message)
{
	if (!IsTribeGame()) { return false; }
	//if (GetSelectedCitizens().size() == 0) { return false; }
	if (!mpEventItem) { mbItemHovered = false; return false; }

	//------------------------------------------------------
	// Event UI Buttons

	if (message.IsType(kMsgButtonClick)) {
		auto id = message.source->GetControlID();
		switch (id) {
			case WinConfirm: EventUIClickButton(1); return true;
			case WinCancel: EventUIClickButton(0); return true;
			case WinClose: HideEventUI(); return true;
		}
	}

	//------------------------------------------------------
	// LEFT

	if (message.IsType(kMsgMouseMove) ) {
		if (rightclick_over_eventitem) {
			mouse_state_valid = false;
		}
		if (!hovering_event_item && IsEventItemHovered()) {
			hovering_event_item = true;
			CursorManager.SetActiveCursor(0x24C6D844);
		}
		else if (hovering_event_item && !IsEventItemHovered()) {
			hovering_event_item = false;
			CursorManager.SetActiveCursor(0x0);
		}
		
	}

	// Checking if left clicking on event item
	if ((message.IsType(kMsgMouseDown) && message.Mouse.IsLeftButton() && IsEventItemHovered())) {
		if (rightclick_over_eventitem) {
			mouse_state_valid = false;
		}
		rightclick_over_eventitem = false;
		return ClickedEventItem(0, true);
	}
	// left click released on event item
	// TODO: suppress the sporepedia asset view at the source.
	else if ( (message.IsType(kMsgMouseMove) && !IsEventItemHovered()) ||
		(message.IsType(kMsgMouseUp) && message.Mouse.mouseButton == kMouseButtonLeft) ) {
		rightclick_over_eventitem = false;
		if (message.IsType(kMsgMouseUp)) {
			mouse_state_valid = true;
		}
		return ClickedEventItem(0, false);
	}

	//------------------------------------------------------
	// RIGHT

	// Checking if right clicking on event item
	else if (message.IsType(kMsgMouseDown) && message.Mouse.IsRightButton() && IsEventItemHovered()) {
		rightclick_over_eventitem = true;
		return false;
	}
	// right click released on event item
	else if (message.IsType(kMsgMouseUp) && message.Mouse.mouseButton == kMouseButtonRight && IsEventItemHovered()) {
		mouse_state_valid = true;
		if (rightclick_over_eventitem && mouse_state_valid) {
			GoToEventItem();
		}
		rightclick_over_eventitem = false;
		return false;
	}

	return false;
	//------------------------------
	// OLD CODE


	// Clicked Left mouse btn OR
	// Moved mouse with button held and item hovered. clear the state.
	if ( (message.Mouse.IsLeftButton() || message.IsType(kMsgMouseMove)) && mbItemHovered) {
		mpEventItem->mpTribe = GameNounManager.GetPlayerTribe();
		if (message.IsType(kMsgMouseMove)) {
			mbCameraMoved = true;
			
		}
		mbItemHovered = false;
		// do not allow left clicking on this item, to prevent showing of fake tribe.
		if (message.Mouse.IsLeftButton() && message.IsType(kMsgMouseDown) && IsEventItemHovered()) {
			return true;
		}
		return false;
	}
	
	// Released mouse button without moving it (allow selecting now!)
	if (message.IsType(kMsgMouseUp)) {
		bool rolled = IsEventItemHovered();
		// If item is hovered and the bool is set, select it and begin special behavior.
		if (rolled && mbItemHovered && !mbCameraMoved) {
			SelectEventItem();
		}
		// do not allow left click release on this item, to prevent showing of fake tribe.
		//else if (left && rolled && !mbCameraMoved) {
		//	mbItemHovered = false;
		//	return true;
		//}
		// If not rolled over the object and not moving the camera, the player is directing the creature to a new task,
		// so remove these creatures from the activators list.
		else if (!rolled && !mbCameraMoved) {
			auto selected = GetSelectedCitizens();
			// loop thru current activators to find matches
			for (size_t i = 0; i < mpActivators.size(); i++) {
				// check this activator against all the selected creatures, and set activator entry to null if a match is found.
				for (auto selected : selected) {
					if (mpActivators[i] == selected) {
						mpActivators[i] = nullptr;
						continue;
					}
				}
			}
		}
		mbItemHovered = false;
		return false;
	}


	// Return true if the message was handled, and therefore no other window procedure should receive it.
	return false;
}

//-----------------------------------------------------------------------------------


Simulator::Attribute TRG_IslandEventManager::ATTRIBUTES[] = {
	// Add more attributes here
	SimAttribute(TRG_IslandEventManager,mpActivators,1),
	SimAttribute(TRG_IslandEventManager,mpEventItem,2),
	SimAttribute(TRG_IslandEventManager,mpDummyTribe,3),
	SimAttribute(TRG_IslandEventManager,mSavedHut,4),
	SimAttribute(TRG_IslandEventManager,mbItemWasClicked,5),
	SimAttribute(TRG_IslandEventManager,mpActivators,6),
	//SimAttribute(TRG_IslandEventManager,mEventItemName,7),
	// This one must always be at the end
	Simulator::Attribute()
};


// You can extend this function to return any other types your class implements.
void* TRG_IslandEventManager::Cast(uint32_t type) const
{
	//CLASS_CAST(Simulator::cStrategy);
	CLASS_CAST(Object);
	CLASS_CAST(IWinProc);
	CLASS_CAST(TRG_IslandEventManager);
	return nullptr;
}