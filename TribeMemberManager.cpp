#include "stdafx.h"
#include "TribeMemberManager.h"
#include "CreatureSpeedBoost.h"
#include "Common.h"

/// AUTOGENERATED METHODS ///

cTribeMemberManager::cTribeMemberManager()
{
	sInstance = this;
	trg_chiefmanager = new(TRG_ChieftainManager);

	SimulatorSystem.AddStrategy(this, NOUN_ID);
}


cTribeMemberManager::~cTribeMemberManager()
{
	sInstance = nullptr;
}

cTribeMemberManager* cTribeMemberManager::sInstance;

cTribeMemberManager* cTribeMemberManager::Get()
{
	return sInstance;
}

int cTribeMemberManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int cTribeMemberManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* cTribeMemberManager::GetName() const {
	return "Valla_CreatureOverhaul::cTribeMemberManager";
}

bool cTribeMemberManager::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cTribeMemberManager::Read(Simulator::ISerializerStream* stream)
{
	Reset();
	auto data = Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
	StoreCurrentBabies();
	Simulator::ScheduleTask(this, &cTribeMemberManager::ApplyAllPersonalities, 0.0001f);
	return data;
}

void cTribeMemberManager::Initialize() {
	LoadIDColors();
	StoreCurrentBabies();
}

void cTribeMemberManager::Dispose() {

}

void cTribeMemberManager::Update(int deltaTime, int deltaGameTime) {
	// TODO: only run if no held creature in cCreaturePickup
	// Pets Rollover
	if (Common::IsPlannerOpen()) { return; }

	auto hovered = GameViewManager.GetHoveredObject();
	if (hovered) {

		
		auto hovered = GameViewManager.GetHoveredObject();
		if (hovered) {
			// Citizen Rollover
			auto citizen = object_cast<cCreatureCitizen>(hovered);
			//if (citizen->mpOwnerTribe && citizen->mpOwnerTribe->IsPlayerOwned() && citizen->IsRolledOver()) {
				//CursorManager.SetActiveCursor(0x0);
			//}
			if (citizen && !citizen->mbDead) {
				UI::SimulatorRollover::ShowRollover(citizen);
			}
			else {
				// Pets Rollover
				auto animal = object_cast<cCreatureAnimal>(hovered);
				if (animal && !animal->mbDead) {
					auto tribe = GameNounManager.mpPlayerTribe;
					if (!tribe) { return; }

					auto pet_herd = tribe->mpDomesticatedAnimalsHerd;
					if (animal->mHerd == pet_herd) {
						UI::SimulatorRollover::ShowRollover(animal);
					}
				}
			}

			
		}
		
	}
}

//------------------------------------------------------------------------------------

void cTribeMemberManager::Reset() {
	mCreatureDesiredTool.clear();
	mCreaturePersonalities.clear();
	ResetSuppressBabyFX();
}

//------------------------------------------------------------------------------------

// populate IDcolors
void cTribeMemberManager::LoadIDColors() {
	PropertyListPtr mpPropList;
	if (PropManager.GetPropertyList(IDcolorsKey.instanceID, IDcolorsKey.groupID, mpPropList))
	{
		App::Property::GetArrayColorRGB(mpPropList.get(), 0x05515FFD, mIDcolors);
	}
}

//------------------------------------------------------------------------------------

void cTribeMemberManager::StoreCurrentBabies() {
	if (GameNounManager.GetPlayerTribe()) {
		mCurrentBabies.clear();
		for (auto member : GameNounManager.GetPlayerTribe()->GetTribeMembers()) {
			if (member->mAge == 0) {
				mCurrentBabies.push_back(member);
			}
		}
	}
}

cCreatureCitizenPtr cTribeMemberManager::GetGrownBaby() {
	cCreatureCitizenPtr grownMember = nullptr;
	for (auto member : mCurrentBabies) {
		if (member->mAge == 1) {
			grownMember = member;
			break;
		}
	}
	StoreCurrentBabies();
	return grownMember;
}

//------------------------------------------------------------------------------------

// load from file
ColorRGB cTribeMemberManager::GetRandColor() const {
	// give slight chance for totally random color
	if (mIDcolors.size() == 0 || randf() < 0.15) { return ColorRGB(randf(), randf(), randf()); }
	// initial randomization
	auto colorIndex = rand(mIDcolors.size());
	// apply some control to what colors can spawn based on the colors of existing members
	int tries = 32;
	bool matchesExisting = false;
	while (matchesExisting && tries > 0) {
		for (auto member : GameNounManager.GetPlayerTribe()->GetTribeMembers()) {
			if (member->mHealthPoints > 0 && mIDcolors[colorIndex] == member->GetIdentityColor()) {
				matchesExisting = true;
				colorIndex = rand(mIDcolors.size());
			}
			else {
				matchesExisting = false;
				break;
			}
		}
		tries--;
	}
	return mIDcolors[colorIndex];
}

void cTribeMemberManager::AssignColor(cCreatureCitizenPtr creature) {
	creature->SetIdentityColor(GetRandColor());
}

//---------------------------------------
// Personality

// Assign the creature a personality struct of color and traits.
void cTribeMemberManager::AssignPersonality(cCreatureCitizenPtr creature) {
	auto personality = MemberPersonality(creature, GetRandColor());
	ApplyPersonality(personality);
	mCreaturePersonalities[creature->mID] = personality;
}

// apply the personality color and etc to the specified creature.
void cTribeMemberManager::ApplyPersonality(MemberPersonality& personality) {
	if (personality.valid && personality.mpCreature) {
		personality.mpCreature->SetIdentityColor(personality.mIDColor);
		personality.mpCreature->mAge = 1;
	}
}

// Forces the creatures to grow up in prep for their ID color. Must do this on load game. Calls ApplyAllPersonalities2().
void cTribeMemberManager::ApplyAllPersonalities() {
	if (!IsTribeGame())  { return; }
	auto tribe = GameNounManager.GetPlayerTribe();
	if (!tribe) { return; }

	for (auto member : tribe->GetTribeMembers()) {
		auto personality = GetPersonality(member);
		if (member->mAge == 1 && personality.valid && personality.mpCreature) {
			personality.mpCreature->mbColorIsIdentity = true;
			mbSuppressBabyGrowFX = true;
			personality.mpCreature->GrowUp();

			// make sure this var resets.
			if (mBabyFXSuppressTask && !mBabyFXSuppressTask->HasExecuted()) {
				App::RemoveScheduledTask(mBabyFXSuppressTask);
			}
			mBabyFXSuppressTask = App::ScheduleTask(this, &cTribeMemberManager::ResetSuppressBabyFX, 0.01f);
		}
	}
	Simulator::ScheduleTask(this, &cTribeMemberManager::ApplyAllPersonalities2, 0.1f);
}

// Apply the personality color and etc to all the creatures.
void cTribeMemberManager::ApplyAllPersonalities2() {
	auto tribe = GameNounManager.GetPlayerTribe();

	for (auto member : tribe->GetTribeMembers()) {
		auto personality = GetPersonality(member);
		if (personality.valid && personality.mpCreature) {
			ApplyPersonality(personality);
		}
	}
}

void cTribeMemberManager::ResetSuppressBabyFX() {
	mbSuppressBabyGrowFX = false;
}


cTribeMemberManager::MemberPersonality cTribeMemberManager::GetPersonality(cCreatureCitizenPtr creature) const {
	auto personalityFind = mCreaturePersonalities.find(creature->mID);
	// if found
	if (personalityFind != mCreaturePersonalities.end()) {
		return personalityFind.get_node()->mValue.second;
	}
	// invalid
	//return nullptr;
	return MemberPersonality();
}



//------------------------------------------------------------------------------------

void cTribeMemberManager::StoreCreatureDesiredTool(cCreatureCitizenPtr creature, int tooltype) {
	mCreatureDesiredTool.insert(make_pair(creature->mID, DesiredToolState(tooltype)));
}
void cTribeMemberManager::SetCreatureDesiredToolGrabState(cCreatureCitizenPtr creature, bool grabbing) {
	mCreatureDesiredTool[creature->mID].mbGrabbing = grabbing;
}
void cTribeMemberManager::RemoveCreatureDesiredTool(cCreatureCitizenPtr creature) {
	auto toolFind = mCreatureDesiredTool.find(creature->mID);
	// if found
	if (toolFind != mCreatureDesiredTool.end()) {
		mCreatureDesiredTool.erase(toolFind);
	}
}
// gets the creature's desired tool from the list, if the tool is being grabbed. return -1 if not found
int cTribeMemberManager::GetCreatureDesiredTool(cCreatureCitizenPtr creature, bool requiregrabbed) {
	auto toolFind = mCreatureDesiredTool.find(creature->mID);
	// if found
	if (toolFind != mCreatureDesiredTool.end()) {
		if (!requiregrabbed || toolFind.get_node()->mValue.second.mbGrabbing) {
			return toolFind.get_node()->mValue.second.mToolTypeID;
		}
	}
	return -1;
}

//------------------------------------------------------------------------------------


namespace Simulator
{
	// Personality
	template <>
	struct SerializationTypes::SerializedType<cTribeMemberManager::MemberPersonality>
	{
		static bool Read(ISerializerReadStream* stream, cTribeMemberManager::MemberPersonality* dst) {
			return Simulator::ClassSerializer(dst, cTribeMemberManager::MemberPersonality::ATTRIBUTES).Read(stream);
		}

		static bool Write(ISerializerWriteStream* stream, cTribeMemberManager::MemberPersonality* src) {

			return Simulator::ClassSerializer(src, cTribeMemberManager::MemberPersonality::ATTRIBUTES).Write(stream);
		}

		static void ReadText(const eastl::string& str, cTribeMemberManager::MemberPersonality* dst) {}

		static void WriteText(char* buf, cTribeMemberManager::MemberPersonality* src) {}
	};

	// DesiredToolState
	template <>
	struct SerializationTypes::SerializedType<cTribeMemberManager::DesiredToolState>
	{
		static bool Read(ISerializerReadStream* stream, cTribeMemberManager::DesiredToolState* dst) {
			return Simulator::ClassSerializer(dst, cTribeMemberManager::DesiredToolState::ATTRIBUTES).Read(stream);
		}

		static bool Write(ISerializerWriteStream* stream, cTribeMemberManager::DesiredToolState* src) {

			return Simulator::ClassSerializer(src, cTribeMemberManager::DesiredToolState::ATTRIBUTES).Write(stream);
		}

		static void ReadText(const eastl::string& str, cTribeMemberManager::DesiredToolState* dst) {}

		static void WriteText(char* buf, cTribeMemberManager::DesiredToolState* src) {}
	};

};


Simulator::Attribute cTribeMemberManager::MemberPersonality::ATTRIBUTES[] = {
		SimAttribute(MemberPersonality, valid, 1),
		SimAttribute(MemberPersonality, mTraits, 2),
		SimAttribute(MemberPersonality, mIDColor, 3),
		SimAttribute(MemberPersonality, mpCreature, 4),
		Simulator::Attribute(),
};

Simulator::Attribute cTribeMemberManager::DesiredToolState::ATTRIBUTES[] = {
		SimAttribute(DesiredToolState, mToolTypeID, 1),
		SimAttribute(DesiredToolState, mbGrabbing, 2),
		Simulator::Attribute(),
};

Simulator::Attribute cTribeMemberManager::ATTRIBUTES[] = {
	// Add more attributes here
	SimAttribute(cTribeMemberManager, mCreaturePersonalities, 1),
	SimAttribute(cTribeMemberManager, mCreatureDesiredTool, 2),
	// This one must always be at the end
	Simulator::Attribute()
};