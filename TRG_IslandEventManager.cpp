#include "stdafx.h"
#include "TRG_IslandEventManager.h"

/// AUTOGENERATED METHODS ///

int TRG_IslandEventManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int TRG_IslandEventManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* TRG_IslandEventManager::GetName() const {
	return "Valla_CreatureOverhaul::TRG_IslandEventManager";
}

bool TRG_IslandEventManager::Write(Simulator::ISerializerStream* stream)
{
	SporeDebugPrint("Island Event Manager is writing...");
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool TRG_IslandEventManager::Read(Simulator::ISerializerStream* stream)
{
	SporeDebugPrint("Island Event Manager is reading...");
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

//-----------------------------------------------------------------------------------

void TRG_IslandEventManager::Initialize() {
	SporeDebugPrint("Island Event Manager is initialized.");

	CursorManager.Load(0x24C6D844, u"cursor_unknown");
	WindowManager.GetMainWindow()->AddWinProc(this);

	eventUIlayout.LoadByID(0xA59316FC);
}

void TRG_IslandEventManager::Dispose() {
	if (mTask) {
		Simulator::RemoveScheduledTask(mTask);
		mTask = nullptr;
	}
}

void TRG_IslandEventManager::Update(int deltaTime, int deltaGameTime) {

}

//-----------------------------------------------------------------------------------

void TRG_IslandEventManager::OnModeEntered(uint32_t previousModeID, uint32_t newModeID) {
	cStrategy::OnModeEntered(previousModeID, newModeID);
	// Entered
	if (newModeID != previousModeID && newModeID == kGameTribe) {
		SporeDebugPrint("Island Event Manager is ready to use in Tribal Stage.");
		StartItemTimer();
		SpawnDummyTribe();
	}
	// Exited
	else {
		if (mTask) {
			Simulator::RemoveScheduledTask(mTask);
			mTask = nullptr;
		}
	}
}

// Generate a tribe on the "dark side" of the planet to use as a fake tribe ID for objects.
void TRG_IslandEventManager::SpawnDummyTribe() {
	// if already exists, return
	if (!IsTribeGame() || mpDummyTribe) { return; }

	// ensure the player tribe exists. if not, wait and run this again.
	auto playerTribe = GameNounManager.GetPlayerTribe();
	if (!playerTribe) { Simulator::ScheduleTask(this, &TRG_IslandEventManager::SpawnDummyTribe, 4.0f); return; }


	mSavedHut = playerTribe->mpHut.get();
	// find the side of the planet opposite of the player, so it is out of sight
	Vector3 pos;
	float tribeDist = Math::distance(Vector3(0, 0, 0), playerTribe->GetPosition());
	// find inverse dir
	Vector3 tribeDir = (Vector3(0, 0, 0) - playerTribe->GetPosition()).Normalized();

	// Spawn tribe
	auto species = playerTribe->mTribeMembers[0]->mpSpeciesProfile;
	mpDummyTribe = Simulator::SpawnNpcTribe(tribeDir * tribeDist, 0, 0, 0, true, species);

	// Make tribe appear destroyed, just to psych out the lore-nerds >:)
	mpDummyTribe->mpHut->mHealthPoints = mpDummyTribe->mpHut->mMaxHealthPoints / 3.0f;
	//auto model = ResourceKey(id("HE_destroyed_hut"), Names::prop, id("hutstyles"));
	//auto model = ResourceKey(id("tt_hut_home_dest"), Names::prop, id("TribalTools"));
	auto model = ResourceKey();
	mpDummyTribe->mpHut->SetModelKey(model);
	mpDummyTribe->mpHut->mDestructModelHi = model;
	mpDummyTribe->mpHut->mDestructModelMd = model;
	mpDummyTribe->mpHut->mDestructModelLo = model;
	mpDummyTribe->mpHut->mUndamagedModel = model;
	// find fire pit, make it appear burned out
	for (auto tool : mpDummyTribe->mTools) {
		if (tool->GetModelKey().instanceID == id("tt_firepit_home_01")) {
			tool->SetModelKey(ResourceKey(id("tt_firepit_home_dest"), Names::prop, id("TribalTools")));
			return;
		}
	}
	
}

// Spawn a chest
void TRG_IslandEventManager::SpawnEventItem() {
	SporeDebugPrint("Spawning Event Item...");
	mbItemHovered = false;

	auto spawnPoint = FindSpawnPoint();
	if (spawnPoint && mpDummyTribe) {
		// pull data from random model file
		auto modelKey = GetEventItemModelKey();
		auto name = GetEventItemName(modelKey);

		mpEventItem = simulator_new<Simulator::cTribeHut>();
		mpEventItem->mpTribe = mpDummyTribe;
		mpDummyTribe->SetName(name);

		mpEventItem->mUndamagedModel = modelKey;
		mpEventItem->SetModelKey(modelKey);
		mpEventItem->Teleport(spawnPoint->GetPosition(), spawnPoint->GetOrientation());
		mpEventItem->mbTransformDirty = false;
		mpEventItem->SetScale(eventItemScale);


		mpEventItem->mbFixed = true;
		mpEventItem->mbPickable = true;
		mpEventItem->mbIsTangible = true;
		mpEventItem->mbIsGhost = false;
	}
	if (!mpEventItem || mpEventItem->GetModelKey() == ResourceKey()) {
		SporeDebugPrint("Spawning Failed.");
	}	

	StartItemTimer();

}

// Remove the chest
void TRG_IslandEventManager::RemoveEventItem() {
	SporeDebugPrint("Removing Event Item");
	mbItemHovered = false;
	mpEventItem->SetIsSelected(false);
	GameNounManager.DestroyInstance(mpEventItem.get());
	mpEventItem = nullptr;
	StartItemTimer();
}

// if the item is onscreen, it cannot be removed!
// call this func again in a second to check if that is still the case.
void TRG_IslandEventManager::TryRemoveEventItem() {
	if (!mpEventItem->mbInView) {
		//mpEventItem->mDistanceFromCamera
		RemoveEventItem();
	}
	else {
		SporeDebugPrint("Unable to remove Event Item.");
		mTask = Simulator::ScheduleTask(this, &TRG_IslandEventManager::TryRemoveEventItem, 1.0f);
	}
}

// Select the chest and store currently selected creatures
void TRG_IslandEventManager::SelectEventItem() {
	mpEventItem->SetIsSelected(true);
	mpEventItem->SetIsRolledOver(true);
	mpActivators.clear();
	mpActivators = GetSelectedCitizens();
}

//---------------------------------

ResourceKey TRG_IslandEventManager::GetEventItemModelKey() {
	// if the item exists, get its current key
	if (mpEventItem) {
		return mpEventItem->GetModelKey();
	}
	// if it does not exist, find a new one from the manifest.
	else {
		// load the event item manifest
		PropertyListPtr mpPropList;
		size_t keycount;
		uint32_t* keys;
		if (PropManager.GetPropertyList(mEventManifestKey.instanceID, mEventManifestKey.groupID, mpPropList))
		{
			if (App::Property::GetArrayUInt32(mpPropList.get(), id("eventModels"), keycount, keys)) {
				if (keycount > 0) {
					int idx = -1;
					int tries = 20;
					while (idx == last_object_idx && tries > 0) {
						tries -= 1;
						idx = rand(keycount);
					}
					last_object_idx = idx;
					return ResourceKey(keys[idx], Names::prop, Models);
				}
			}
		}
	}
	return ResourceKey();
}

ResourceKey TRG_IslandEventManager::GetEventPrompt(ResourceKey res) const {
	// load the event item manifest
	PropertyListPtr mpPropList;
	size_t keycount;
	ResourceKey* keys;
	if (PropManager.GetPropertyList(res.instanceID, res.groupID, mpPropList))
	{
		if (App::Property::GetArrayKey(mpPropList.get(), id("resultEvents"), keycount, keys)) {
			if (keycount > 0) {
				int idx = rand(keycount);
				return keys[idx];
			}
		}
	}
	return ResourceKey();
}

const char16_t* TRG_IslandEventManager::GetEventItemName(ResourceKey model) const {
	PropertyListPtr mpPropList;
	LocalizedString localetext;
	if (PropManager.GetPropertyList(model.instanceID, model.groupID, mpPropList))
	{
		if (App::Property::GetText(mpPropList.get(), 0x8F6FC401, localetext)) { // blockname
			return localetext.GetText();
		}
	}
	return LocalizedString().GetText();
}



//-----------------------------------------------------------------------------------

// TODO: fix offscreen object deletion to work, bump up timers
void TRG_IslandEventManager::StartItemTimer() {
	float time;
	// no item, start timer to spawn one in
	if (!mpEventItem) {
		time = GetFloatFromVecRange(timeBetweenSpawns);
		mTask = Simulator::ScheduleTask(this, &TRG_IslandEventManager::SpawnEventItem, time);
	}
	// item exists, start timer to delete it.
	else {
		time = GetFloatFromVecRange(timeItemLifetime);
		mTask = Simulator::ScheduleTask(this, &TRG_IslandEventManager::TryRemoveEventItem, time);
	}
}

cSpatialObjectPtr TRG_IslandEventManager::FindSpawnPoint() {
	vector<cSpatialObjectPtr> spawnpoints = {};
	for (auto item : GetDataByCast<cSpatialObject>()) {
		if (item->GetModelKey().instanceID == id("TRG_lootmarker_beach")) { //id("cr_flr_coastal_large01")
			spawnpoints.push_back(item);
		}
	}
	if (spawnpoints.size() > 0) {
		return spawnpoints[rand(spawnpoints.size())];
	}
	return nullptr;
}

float TRG_IslandEventManager::GetFloatFromVecRange(Vector2 range) const {
	float diff = range.y - range.x;
	return (randf() * diff) + range.x;
}

vector<cCreatureCitizenPtr> TRG_IslandEventManager::GetSelectedCitizens() const {
	vector<cCreatureCitizenPtr> selectedCreatures = {};
	auto tribe = GameNounManager.GetPlayerTribe();
	if (!tribe) { return selectedCreatures; }
	for (auto creature : tribe->GetTribeMembers()) {
		if (creature->IsSelected()) {
			selectedCreatures.push_back(creature);
		}
		
	}
	return selectedCreatures;
}

bool TRG_IslandEventManager::IsEventItemHovered() const {
	if (mpEventItem) {
		return mpEventItem->IsRolledOver();
	}
	return false;
}

/*
bool TRG_IslandEventManager::TraceCanHandleModel(Graphics::Model* model) {
	if (object_cast<cGamePlant>(model->mpOwner)) { return false; }
	return true;
}

bool TRG_IslandEventManager::TraceHitEventObject() const {

	auto pViewer = CameraManager.GetViewer();

	Vector3 camPos = Vector3(0, 0, 0);
	Vector3 camDir = Vector3(0, 0, 0);

	// Get vector to the center of the screen.
	auto windowArea = WindowManager.GetMainWindow()->GetArea();
	pViewer->GetCameraToMouse(camPos, camDir);

	vector<cSpatialObjectPtr> raycastObjects;

	if (GameViewManager.RaycastAll(camPos, camPos + (camDir * 900.0f), raycastObjects, true)) {
		for (auto object : raycastObjects) {
			// if hit a tribal building before an object, return false.
			//if (object_cast<cTribeTool>(object) || object_cast<cTribeHut>(object)) {
			//	return false;
			//}
			//auto worldObject = object_cast<cInteractiveOrnament>(object);
			auto worldObject = object_cast<cTribeHut>(object);
			if (worldObject && worldObject == mpEventItem) {
				return true;
			}
		}

	}
	return false;
}*/

//-----------------------------------------------------------------------------------

bool TRG_IslandEventManager::ClickedEventItem(int mouseButton, bool clicked) {
	if (mouseButton == 0) {
		auto window = WindowManager.GetMainWindow();
		auto playerTribe = GameNounManager.GetPlayerTribe();
		if (clicked) {
			if (mUITask && !mUITask->HasExecuted()) {
				//Simulator::RemoveScheduledTask(mUITask);
				return true;
			}
			mpEventItem->mpTribe = playerTribe;

			auto itemnamefield = window->FindWindowByID(kItemNameField);
			if (itemnamefield) {
				itemnamefield->SetCaption(mpDummyTribe->GetName());
			}
		}
		else {
			// do this to prevent the window from jumping around
			if (IsEventItemHovered()) {
				playerTribe->mpHut = mpEventItem;
			}
			if (mUITask && !mUITask->HasExecuted()) {
				Simulator::RemoveScheduledTask(mUITask);
			}
			mUITask = Simulator::ScheduleTask(this, &TRG_IslandEventManager::UnLeftClickedEventItem, 0.0001f);
			return false;
		}
	}
	return false;
}

// This is its own func since it needs to be delayed.
void TRG_IslandEventManager::UnLeftClickedEventItem() {
	if (mpEventItem) {
		auto playertribe = GameNounManager.GetPlayerTribe();
		if (IsEventItemHovered()) {
			if (mSavedHut) {
				playertribe->mpHut = mSavedHut;
			}
		}
		
		mpEventItem->mpTribe = mpDummyTribe;
	}
}


//-----------------------------------------------------------------------------------
// Custom UI Funcs

// TODO: use the part model to find a list of prompts to show.
// Then use the randomly chosen prompt to fill out data in the UI
void TRG_IslandEventManager::ShowEventUI() {
	GameTimeManager.Pause(TimeManagerPause::Cinematic);

	eventUIlayout.FindWindowByID(WinMain)->SetVisible(true);
	eventUIlayout.FindWindowByID(WinShadow)->SetVisible(true);

	FillEventUIData(GetEventPrompt(mpEventItem->GetModelKey()));
}

void TRG_IslandEventManager::HideEventUI() {
	eventUIlayout.FindWindowByID(WinMain)->SetVisible(false);
	eventUIlayout.FindWindowByID(WinShadow)->SetVisible(false);
	GameTimeManager.Resume(TimeManagerPause::Cinematic);
}

void TRG_IslandEventManager::EventUIClickButton(bool confirmed) {
	HideEventUI();
}

// load the UI data from the event item's prop file, and assign it to the window
void TRG_IslandEventManager::FillEventUIData(ResourceKey eventPromptKey) {
	//ResourceKey mEventPromptKey = GetEventPrompt(mpEventItem->GetModelKey());

	// load the properties of the model
	PropertyListPtr mpPropList;
	ResourceKey key;
	if (PropManager.GetPropertyList(eventPromptKey.instanceID, eventPromptKey.groupID, mpPropList))
	{
		LocalizedString eventText = LocalizedString();
		LocalizedString eventTextCancelled = LocalizedString();
		LocalizedString textConfirm = LocalizedString();
		LocalizedString textCancel = LocalizedString();
		ResourceKey eventImageID = ResourceKey();

		App::Property::GetText(mpPropList.get(), id("eventText"), eventText);
		App::Property::GetText(mpPropList.get(), id("eventTextCancelled"), eventTextCancelled);
		App::Property::GetText(mpPropList.get(), id("textConfirm"), textConfirm);
		App::Property::GetText(mpPropList.get(), id("textCancel"), textCancel);
		App::Property::GetKey(mpPropList.get(), id("eventImageID"), eventImageID);

		auto imagefield = eventUIlayout.FindWindowByID(WinImage);
		auto textfield = eventUIlayout.FindWindowByID(WinText);
		auto confirm = eventUIlayout.FindWindowByID(WinConfirm);
		auto cancel = eventUIlayout.FindWindowByID(WinCancel);
		auto close = eventUIlayout.FindWindowByID(WinClose);

		textfield->SetCaption(eventText.GetText()); // TODO: swap text variables. make a static func for this.
		object_cast<UTFWin::IImageDrawable>(imagefield->GetDrawable())->SetImageForWindow(imagefield, eventImageID);
		//image->(eventText.GetText()); // TODO: swap names

		// show prompt buttons
		if (!string16(textConfirm.GetText()).empty()) {

			close->SetVisible(false);

			confirm->SetVisible(true);
			confirm->SetCaption(textConfirm.GetText());

			cancel->SetVisible(true);
			cancel->SetCaption(textCancel.GetText());
		}
		// show close button
		else {
			close->SetVisible(true);
			confirm->SetVisible(false);
			cancel->SetVisible(false);
		}

		
	}
}

//-----------------------------------------------------------------------------------

int TRG_IslandEventManager::GetEventFlags() const
{
	return kEventFlagBasicInput | kEventFlagAdvanced;
}

// Ingame mouse messages
bool TRG_IslandEventManager::HandleUIMessage(IWindow* window, const Message& message)
{
	if (!IsTribeGame()) { return false; }
	//if (GetSelectedCitizens().size() == 0) { return false; }
	if (!mpEventItem) { mbItemHovered = false; return false; }

	//------------------------------------------------------
	// Event UI Buttons

	if (message.IsType(kMsgButtonClick)) {
		auto id = message.source->GetControlID();
		switch (id) {
			case WinConfirm: EventUIClickButton(1); return true;
			case WinCancel: EventUIClickButton(0); return true;
			case WinClose: HideEventUI(); return true;
		}
	}

	//------------------------------------------------------
	// LEFT

	// Checking if left clicking on event item
	if ((message.IsType(kMsgMouseDown) && message.Mouse.IsLeftButton() && IsEventItemHovered())) {
		return ClickedEventItem(0, true);
	}
	// left click released on event item
	else if ( (message.IsType(kMsgMouseMove) && !IsEventItemHovered()) ||
		(message.IsType(kMsgMouseUp) && message.Mouse.mouseButton == kMouseButtonLeft) ) {
		
		return ClickedEventItem(0, false);
	}

	//------------------------------------------------------
	// RIGHT

	// Checking if right clicking on event item
	else if (message.IsType(kMsgMouseDown) && message.Mouse.IsRightButton() && IsEventItemHovered()) {
		ShowEventUI();
		return true;
	}

	return false;
	//------------------------------
	// OLD CODE


	// Clicked Left mouse btn OR
	// Moved mouse with button held and item hovered. clear the state.
	if ( (message.Mouse.IsLeftButton() || message.IsType(kMsgMouseMove)) && mbItemHovered) {
		mpEventItem->mpTribe = GameNounManager.GetPlayerTribe();
		if (message.IsType(kMsgMouseMove)) {
			mbCameraMoved = true;
			
		}
		mbItemHovered = false;
		// do not allow left clicking on this item, to prevent showing of fake tribe.
		if (message.Mouse.IsLeftButton() && message.IsType(kMsgMouseDown) && IsEventItemHovered()) {
			return true;
		}
		return false;
	}
	
	// Released mouse button without moving it (allow selecting now!)
	if (message.IsType(kMsgMouseUp)) {
		bool rolled = IsEventItemHovered();
		// If item is hovered and the bool is set, select it and begin special behavior.
		if (rolled && mbItemHovered && !mbCameraMoved) {
			SelectEventItem();
		}
		// do not allow left click release on this item, to prevent showing of fake tribe.
		//else if (left && rolled && !mbCameraMoved) {
		//	mbItemHovered = false;
		//	return true;
		//}
		// If not rolled over the object and not moving the camera, the player is directing the creature to a new task,
		// so remove these creatures from the activators list.
		else if (!rolled && !mbCameraMoved) {
			auto selected = GetSelectedCitizens();
			// loop thru current activators to find matches
			for (size_t i = 0; i < mpActivators.size(); i++) {
				// check this activator against all the selected creatures, and set activator entry to null if a match is found.
				for (auto selected : selected) {
					if (mpActivators[i] == selected) {
						mpActivators[i] = nullptr;
						continue;
					}
				}
			}
		}
		mbItemHovered = false;
		return false;
	}


	// Return true if the message was handled, and therefore no other window procedure should receive it.
	return false;
}

//-----------------------------------------------------------------------------------


Simulator::Attribute TRG_IslandEventManager::ATTRIBUTES[] = {
	// Add more attributes here
	SimAttribute(TRG_IslandEventManager,mpActivators,1),
	SimAttribute(TRG_IslandEventManager,mpEventItem,2),
	SimAttribute(TRG_IslandEventManager,mpDummyTribe,3),
	SimAttribute(TRG_IslandEventManager,mSavedHut,4),
	// This one must always be at the end
	Simulator::Attribute()
};


// You can extend this function to return any other types your class implements.
void* TRG_IslandEventManager::Cast(uint32_t type) const
{
	//CLASS_CAST(Simulator::cStrategy);
	CLASS_CAST(Object);
	CLASS_CAST(IWinProc);
	CLASS_CAST(TRG_IslandEventManager);
	return nullptr;
}