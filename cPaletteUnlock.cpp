#include "stdafx.h"
#include "cPaletteUnlock.h"

// 2-func Hack to get this func working

void cPaletteUnlockStructs::PaletteUnlockData::PopulatePaletteParts()
{
	GetUnlockCategories();

	// The item loading detour for palette will load the items into this hash map
	PaletteUnlockManager.bLoadPartCoords = true;
	PaletteUnlockManager.pLoadedPartCoords.clear();

	// Load full parts palettes from mEditorPaletteIDs
	PaletteMainPtr palette = new(PaletteMain);
	for (const auto item : mEditorPaletteIDs) {
		bool read = palette->ReadProp({ item, prop, 0x406b6a00 }); // palette_definition~
	}

	// Loop through all categories, subcategories, and pages to find palette items.
	for (const PaletteCategoryPtr cat : palette->mCategories) {
		eastl::vector<PaletteCategoryPtr> subCats = cat->mChildren;
		if (subCats.size() == 0) {
			subCats.push_back(cat);
		}

		for (const PaletteCategoryPtr subCat : subCats) {
			for (size_t p = 0; p < subCat->mPages.size(); p++) {
				// standard editor/planner
				if (subCat->mPages[p]->mItems.size() > 0) {
					for (const PaletteItemPtr item : subCat->mPages[p]->mItems) {
						if (item) {
							// add Unlockable item if in a valid category (or no categories set)
							if (mPartUnlockCategories.size() == 0) {
								AddUnlockableItem(item, cat->mCategoryID, p, PaletteUnlockManager.pLoadedPartCoords[item->mName]);
								break;
							}
							else {
								for (size_t i = 0; i < mPartUnlockCategories.size(); i++) {
									if (cat->mCategoryID == mPartUnlockCategories[i]) {
										AddUnlockableItem(item, cat->mCategoryID, p, PaletteUnlockManager.pLoadedPartCoords[item->mName]);
										break;
									}
								}
							}
							
							// Unlock item if itemUnlockFindPercentage >= 1.0
							// NOTE: this ignores mPartUnlockCategories.
							float itemUnlockFindPercentage = CapabilityChecker::GetModelFloatValue(item->mName, 0x03A289C3);
							if (itemUnlockFindPercentage >= 1) {
								Unlock(item->mName, false, false);
							}
						}
					}
				}
			}
		}
	}
	PaletteUnlockManager.pLoadedPartCoords.clear();
	PaletteUnlockManager.bLoadPartCoords = false;
}

// Log parts to pLoadedPartCoords
void cPaletteUnlock::ED_ReadItemsModule_detour(const ResourceKey& moduleName) {
	if (!bLoadPartCoords) return;
	// load in what parts correspond to what rows/columns
	vector<int> palettePagePartItemColumns = CapabilityChecker::GetModelIntValues(moduleName, 0x22C47931);
	vector<int> palettePagePartItemRows = CapabilityChecker::GetModelIntValues(moduleName, 0xF8E99C4F);
	vector<ResourceKey> palettePagePartItems = CapabilityChecker::GetModelKeyValues(moduleName, 0xEEEAD734);
	// aggregate matching data and add to pLoadedPartCoords
	size_t size = min(min(palettePagePartItems.size(), palettePagePartItemColumns.size()), palettePagePartItemRows.size());
	for (size_t i = 0; i < size; i++) {
		Vector2 coords = { (float)palettePagePartItemColumns[i], (float)palettePagePartItemRows[i] };
		pLoadedPartCoords[palettePagePartItems[i]] = coords;
	}
}


//-----------------------------------------------------------------------------------------------------------------------------------


cPaletteUnlock::cPaletteUnlock()
{
	sInstance = this;
	//WindowManager.GetMainWindow()->AddWinProc(this);
	SimulatorSystem.AddStrategy(this, NOUN_ID);
	// Add message listeners
	for (uint32_t id : messages) {
		MessageManager.AddListener(this, id);
	}
	
}

cPaletteUnlock::~cPaletteUnlock()
{
	mpLastPalette = nullptr;
	sInstance = nullptr;
}

cPaletteUnlock* cPaletteUnlock::sInstance;

bool cPaletteUnlock::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cPaletteUnlock::Read(Simulator::ISerializerStream* stream)
{
	ClearSaveData();
	auto value = Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
	InitializeSaveData();
	return value;
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

void cPaletteUnlock::Initialize() {
	
}

void cPaletteUnlock::Dispose() {
	
}

void cPaletteUnlock::Update(int deltaTime, int deltaGameTime) {
	
}

//-------------------------------------------------------------------------

void cPaletteUnlock::ClearSaveData() {
	mPaletteUnlocks.clear();
}

void cPaletteUnlock::InitializeSaveData() {
	if (!IsStageGameMode()) { return; }
	if (mPaletteUnlocks.empty() || !IsValidPlayer()) {
		mPaletteUnlocks.clear();
		mPaletteUnlocks = {
			{ kGameCell, PaletteUnlockData({0x00000001, 0x00000005}, id("CellGame"))},
			{ kGameCreature, PaletteUnlockData(0x0000000C, id("CreatureGame")) },
			{ kGameTribe, PaletteUnlockData({0x000000CA, 0x000000C9}, id("TribeGame")) }, // tribe and civ acc palettes
			{ kGameSpace, PaletteUnlockData(0x000000CB, 0x0)}, // 0x31DA3CEA for 2nd value?
		};


		// Fill out the data
		auto it = mPaletteUnlocks.begin();
		while (it != mPaletteUnlocks.end()) {
			(it->second).mCollectionID = it->first;
			ResourceKey species = {};
			if (GetGameModeID() == it->first) {
				switch (it->first) {
					case kGameCreature: species = GameNounManager.GetAvatar()->mSpeciesKey; break;
					case kGameCell: species = Simulator::Cell::GetPlayerCell()->mModelKey; break;
				}
			}

			(it->second).Populate(species);
			it.increment();
		}
	}
	mSaveGameID = GetPlayer()->mUniqueGameID;
}

bool cPaletteUnlock::IsValidPlayer() const
{
	if (mSaveGameID == GetPlayer()->mUniqueGameID) {
		return true;
	}
	return false;
}


// Editor palette UI is being loaded. Apply unlock data if applicable.
// TODO: should this be moved to when the editor model is set? for editing creations that are not fully unlocked
void cPaletteUnlock::EditorPaletteUILoad(PaletteUI* palette) {
	mpLastPalette = palette;
	// NOTE: this func fires multiple times, and only the last one counts. Put anything that needs to run LAST in EditorPaletteUILoadDone.

	// NOTE: This assumes that mLastGameMode and mCurrentGameMode are swapped.
	// If this is changed, this code will need to be swapped.
	if (mLastGameMode == kEditorMode && mPaletteUnlocks.find(mCurrentGameMode) != mPaletteUnlocks.end()) {
		auto data = &mPaletteUnlocks[mCurrentGameMode];
		EditorApplyPaletteUnlockData(data);
	}
}

// Finished loading into the editor.
void cPaletteUnlock::EditorPaletteUILoadDone(const PaletteUI* palette) {
	if (mLastGameMode == kEditorMode && mPaletteUnlocks.find(mCurrentGameMode) != mPaletteUnlocks.end()) {
		mPaletteUnlocks[mCurrentGameMode].MarkItemsRead();
	}
}

//-------------------------------------------------------------------------

// Get the editor or planner's palette UI
PaletteUIPtr cPaletteUnlock::GetCurrentPaletteUI() const
{
	if (!(GetEditor() && GetEditor()->IsActive())) {
		return GetEditor()->mpPartsPaletteUI;
	}
	else if (mpLastPalette) {
		return mpLastPalette;
	}
	return nullptr;
}

// Apply unlock data to current editor/planner palette. If no palette is open, do nothing.
void cPaletteUnlock::EditorApplyPaletteUnlockData(PaletteUnlockData* data) {
	if (!data) { return; }
	PaletteUIPtr palette = GetCurrentPaletteUI();
	if (!palette) { return; }

	auto items = GetPaletteItemUIs(GetCurrentPaletteUI()); // data->mLimitToCategoryIDs
	for (size_t i = 0; i < items.size(); i++) {
		auto unlockable = data->GetUnlockedItem(items[i]->mpItem->mName);
		if (!unlockable) {
			ItemSetLocked(items[i]);
		}
		else {
			if (unlockable->mbHidden) {
				ItemSetDisabled(items[i]);
			} else if (unlockable->mbNewItem) {
				ItemSetNewHighlight(items[i]);
			}
			// Mark new items as no longer new, if already in editor
			if (Editor.GetEditorModel() && Editor.GetEditorModel()->mKey.instanceID) {
				unlockable->mbNewItem = false;
			}
		}
	}
}

//---------------------------------------------------------------------------------

bool cPaletteUnlock::HandleMessage(uint32_t messageID, void* msg)
{

	if (messageID == id("UnlockPart")) {
		// DEBUG
		auto data = &(mPaletteUnlocks[kGameCreature]);
		auto datacell = &(mPaletteUnlocks[kGameCell]);
		//data->Unlock(ResourceKey(id("ce_mouth_jaw_carnivore_01"), prop, 0x40626000));
		//data->Unlock(ResourceKey(id("ce_mouth_jaw_carnivore_02"), prop, 0x40626000));
		//data->Unlock(ResourceKey(id("ce_mouth_jaw_carnivore_03"), prop, 0x40626000));
		//data->Unlock(ResourceKey(id("ce_mouth_jaw_carnivore_04"), prop, 0x40626000));
		//data->Unlock(ResourceKey(id("ce_mouth_radial_omnivore_01"), prop, 0x40626000));
		//data->Unlock(ResourceKey(id("ce_mouth_radial_omnivore_02"), prop, 0x40626000));
		//data->Unlock(ResourceKey(id("ce_cell_sense_eye_black_01"), prop, 0x40626000));
		data->Unlock(ResourceKey(id("ce_sense_eye_valla_cute_01"), prop, 0x40626000));
		datacell->Unlock(ResourceKey(id("cl_mouth_filter_01"), prop, 0x40616000));
		EditorApplyPaletteUnlockData(data);
		EditorApplyPaletteUnlockData(datacell);
	}
	// Un/Loading new games or savegames
	else if (messageID == kMessageLoadGame || messageID == kMsgSwitchGameMode) {
		Simulator::ScheduleTask(this, &cPaletteUnlock::InitializeSaveData, 0.001f);
	}

	return false;
}

 
//---------------------------------------------------------------------------------


/// Simulator Data ///
//////////////////////


namespace Simulator
{
	// UnlockableItem
	template <>
	struct SerializationTypes::SerializedType<cPaletteUnlock::UnlockedItem>
	{
		static bool Read(ISerializerReadStream* stream, cPaletteUnlock::UnlockedItem* dst) {
			return Simulator::ClassSerializer(dst, cPaletteUnlock::UnlockedItem::ATTRIBUTES).Read(stream);
		}

		static bool Write(ISerializerWriteStream* stream, cPaletteUnlock::UnlockedItem* src) {

			return Simulator::ClassSerializer(src, cPaletteUnlock::UnlockedItem::ATTRIBUTES).Write(stream);
		}

		static void ReadText(const eastl::string& str, cPaletteUnlock::UnlockedItem* dst) {}

		static void WriteText(char* buf, cPaletteUnlock::UnlockedItem* src) {}
	};

	// PaletteUnlockData
	template <>
	struct SerializationTypes::SerializedType<cPaletteUnlock::PaletteUnlockData>
	{
		static bool Read(ISerializerReadStream* stream, cPaletteUnlock::PaletteUnlockData* dst) {
			return Simulator::ClassSerializer(dst, cPaletteUnlock::PaletteUnlockData::ATTRIBUTES).Read(stream);
		}

		static bool Write(ISerializerWriteStream* stream, cPaletteUnlock::PaletteUnlockData* src) {

			return Simulator::ClassSerializer(src, cPaletteUnlock::PaletteUnlockData::ATTRIBUTES).Write(stream);
		}

		static void ReadText(const eastl::string& str, cPaletteUnlock::PaletteUnlockData* dst) {}

		static void WriteText(char* buf, cPaletteUnlock::PaletteUnlockData* src) {}
	};

};

Simulator::Attribute cPaletteUnlock::UnlockedItem::ATTRIBUTES[] = {
	SimAttribute(UnlockedItem, mKey, 1),
	SimAttribute(UnlockedItem, mbNewItem, 2),
	SimAttribute(UnlockedItem, mbHidden, 3),
	Simulator::Attribute(),
};

Simulator::Attribute cPaletteUnlock::PaletteUnlockData::ATTRIBUTES[] = {
	SimAttribute(PaletteUnlockData, mCollectionID, 1),
	SimAttribute(PaletteUnlockData, mEditorPaletteIDs, 2),
	SimAttribute(PaletteUnlockData, mUnlockedItems, 3),
	SimAttribute(PaletteUnlockData, mPartUnlockConfigID, 4),
	Simulator::Attribute(),
};

Simulator::Attribute cPaletteUnlock::ATTRIBUTES[] = {
	SimAttribute(cPaletteUnlock, mPaletteUnlocks, 1),
	SimAttribute(cPaletteUnlock, mSaveGameID, 2),
	Simulator::Attribute()
};

